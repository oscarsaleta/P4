#
# This file was automatically generated by MPLSTRIP.
# Source file: tools.tex
# Time stamp on source file: Wed Jul 11 14:19:41 2018
#
restart;
rounded := false:
Hardware_precision := floor(evalhf(Digits)):
user_precision := Hardware_precision:

currentopenfile := {-infinity}:
openfilelist := {}:

reduce_imp := z -> evalf(reduce_im(z)):
reduce_re :=  z -> (z + reduce_conj(z))/2:
reduce_im :=  z -> (z - reduce_conj(z))/(2*I):

reduce_llt :=   (a,b) -> evalb(evalf(a-b) <= -10^(-user_precision)):
reduce_gt :=    (a,b) -> evalb(evalf(a-b) >= 10^(-user_precision)):
reduce_gteq :=  (a,b) -> evalb(evalf(a-b) >= -10^(-user_precision)):
reduce_eeq :=   (a,b) ->  evalb(evalf(abs(a-b)) < 10^(-user_precision)):
reduce_nneq :=  (a,b) -> evalb(evalf(abs(a-b)) >= 10^(-user_precision)):

reduce_evalf := evalf:
reduce_conj :=  conjugate:

norpoly := (P,x) -> if user_simplify then expand(user_simplifycmd(normal(P))) else expand(normal(P)) end if;
norpoly2 := (P,x,y) -> if user_simplify then expand(user_simplifycmd(normal(P))) else expand(normal(P)) end if;
norpoly3 := (P,x,y,z) -> if user_simplify then expand(user_simplifycmd(normal(P))) else expand(normal(P)) end if;

reduce_coeff := proc(f, x)
    local g, g1, g2, j;
    g := norpoly(f,x);
    g1 := numer(g);
    g2 := denom(g);
    if g1 = 0 then [0] else [ coeff(g1, x, j)/g2 $ j = 0..degree(g1, x) ] fi;
end:
openfile := proc()
    local kk, k, fh, fname;
    global currentopenfile, openfilelist;
    currentopenfile := {};

    for kk from 1 to nargs do
        fname := eval(args[kk]);
        if fname = terminal then
            currentopenfile := currentopenfile union { -infinity }
        else
            for k from 1 to nops(openfilelist) do
                if op(1,openfilelist[k]) = fname then break fi
            od;
            if k <= nops(openfilelist) then
                currentopenfile := currentopenfile union { op(2,openfilelist[k]) }
            else
                fh := fopen(fname, WRITE, TEXT);
                currentopenfile := currentopenfile union { fh };
                openfilelist := openfilelist union { [ fname, fh ] }
            fi
        fi
    od;
    if nops(currentopenfile)=0 then
        currentopenfile := {-infinity}
    fi;
end:
closefile := proc(filename)
    local k;
    global currentopenfile, openfilelist;

    if filename <> terminal then
        for k from 1 to nops(openfilelist) do
            if op(1,openfilelist[k]) = filename then
                break
            fi
        od;

        if k <= nops(openfilelist) then
            fclose(op(2,openfilelist[k]));
            if member(op(2,openfilelist[k]), currentopenfile) then
                currentopenfile := currentopenfile minus {op(2,openfilelist[k])};
                if nops(currentopenfile) = 0 then
                    currentopenfile := {-infinity}
                fi;
            fi;
            openfilelist := openfilelist minus { openfilelist[k] }
        fi

    else
        # filename=terminal
        if member(-infinity, currentopenfile) and nops(currentopenfile)>1 then
            currentopenfile := currentopenfile minus {-infinity};
        fi;
    fi;
end:

closeallfiles := proc(filename)
    while nops(openfilelist) <> 0 do
        closefile(op(1, openfilelist[1]))
    od
end:

write_number := proc(n)
    if rounded then
        writef("%g\n", evalf(n))
    else
        writef("%a\n", n) fi;
end:
writef := proc(formatstring)
    local j;
    for j from 1 to nops(currentopenfile) do
        if currentopenfile[j] = -infinity then
            printf(formatstring, args[2..nargs])
        else
            fprintf(currentopenfile[j], formatstring, args[2..nargs])
        fi
    od;
end:
optimizepolynomial1 := proc(f, x)
    local g, L, j, k, z;
    global user_precision, rounded;
    g := norpoly(f,x);
    if not rounded then
        g := convert(g, rational)
    else
        g := evalf(g)
    fi;
    L := eval([ 'coeff(g, x, j)' $ j = 0..max(0,degree(g,x)) ]);
    if not(rounded) and user_simplify then
        L := map(user_simplifycmd,L)
    fi;
    L := map(z ->
        if type(evalf(z),numeric) then
            if abs(evalf(z)) <= 10^(-user_precision) then
                0
            else
                z
            end if
        else
            z
        end if, L);
    eval(add(L[k]*x^(k-1), k=1..nops(L)))
end:

optimizepolynomial2 := proc(f, x, y)
    local g, j, L, z;
    global rounded;
    g := norpoly2(f,x,y);
    if not rounded then
        g := convert(g, rational)
    else
        g := evalf(g)
    fi;
    L := eval([ 'coeff(g, x, j)' $ j = 0..max(0,degree(g,x)) ]);
    L := map(z -> optimizepolynomial1(z, y), L);
    norpoly(eval(add(L[k]*x^(k-1), k=1..nops(L))), x);
end:

optimizevf :=  (f, x, y) ->
    [ optimizepolynomial2(f[1],x,y), optimizepolynomial2(f[2], x, y) ]:

change_poly := proc(f, x, y)
    local g, h, k, a;
    g := norpoly2(f, x, y);
    h := 0;
    while g <> 0 do
        k := nlterm(g, x, y);
        g := g - k;
        a := eval(eval(k, x=1), y=1);
        if abs(evalf(a)) > 10^(-user_precision) then h := h + k fi
    od;
    h
end:

first_term := proc(_f, x)
    local f;
    f := optimizepolynomial1(_f, x);
    if f = 0 then 0 else coeff(f, x, ldegree(f,x))*x^(ldegree(f,x)) fi;
end:

lleadterm := proc(_f, x)
    local f;
    f := optimizepolynomial1(_f, x);
    if f = 0 then 0 else coeff(f, x, degree(f,x))*x^(degree(f,x)) fi;
end:

nlterm := proc(f, x, y)
    local g, h;
    g := norpoly(lleadterm(f, x), y);
    if g <> 0 then
        h := lleadterm(g, y);
        if h <> 0 then h else g fi
    else
        g := norpoly(lleadterm(f, y), x);
        if g <> 0 then g else f fi
    fi
end:

ddeg := proc(_f, x, y)
    local f;
    global rounded;
    f := optimizepolynomial2(_f, x, y);
    if f = 0 then 0 else degree(f, {x,y}) fi
end:

low_ddeg := proc(_f, x, y)
    local f;
    f := optimizepolynomial2(_f, x, y);
    if f = 0 then 0 else ldegree(f, {x,y}) fi
end:

low_deg1 := proc(_f, x)
    local f;
    f := evalf(norpoly(_f), x);
    if f = 0. then 0 else ldegree(f, x) fi
end:

nterm := proc(_f, x, y, d)
    local f, j, g;
    f := optimizepolynomial2(_f, x, y);
    g := 0;
    for j from 0 to d do
        g := g + coeff(coeff(f, x, j), y, d-j)*x^j*y^(d-j);
    od;
    g
end:

quasihom_degree1 := proc(_f, x, y, p, q)
    local _x, _y, f;
    f := optimizepolynomial2(_f, x, y);
    f := subs(x=_x^p, y=_y^q, f);
    degree(f, {_x, _y})
end:

quasihom_degree :=(vf, x, y, p, q) ->
    max(quasihom_degree1(vf[1],x,y,p,q) - p, quasihom_degree1(vf[2],x,y,p,q) - q):
sort_list := s -> sort(s, (sle_a,sle_b) ->
    evalb((sle_a[1] < sle_b[1]) or (sle_a[1] = sle_b[1] and sle_a[2] < sle_b[2]))):

save(rounded, Hardware_precision, user_precision, reduce_coeff, write_number,
      reduce_evalf, reduce_llt, reduce_gt, reduce_gteq, reduce_eeq, reduce_nneq,
      optimizepolynomial1, optimizepolynomial2, first_term, lleadterm, nlterm,
      ddeg, low_ddeg, nterm, low_deg1, optimizevf, quasihom_degree1,
      quasihom_degree, change_poly, sort_list, reduce_imp,
      reduce_conj, reduce_re, reduce_im, openfile, closefile, writef,
      currentopenfile, openfilelist, closeallfiles, norpoly, norpoly2, norpoly3,
      "tools.m");
