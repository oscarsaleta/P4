#
# This file was automatically generated by MPLSTRIP.
# Source file: tools.tex
# Time stamp on source file: Wed Jun 13 11:03:01 2018
#
restart;
rounded := false:
Hardware_precision := floor(evalhf(Digits)):
user_precision := Hardware_precision:

currentopenfile := {-infinity}:
openfilelist := {}:

reduce_imp := z -> evalf( reduce_im(z) ):
reduce_re :=  z -> (z + reduce_conj(z))/2:
reduce_im :=  z -> (z - reduce_conj(z))/(2*I):

reduce_llt :=   (a,b) -> evalb( evalf( a-b ) <= -10^(-user_precision) ):
reduce_gt :=    (a,b) -> evalb( evalf( a-b ) >= 10^(-user_precision) ):
reduce_gteq :=  (a,b) -> evalb( evalf( a-b ) >= -10^(-user_precision) ):
reduce_eeq :=   (a,b) ->  evalb( evalf( abs(a-b) ) < 10^(-user_precision) ):
reduce_nneq :=  (a,b) -> evalb( evalf( abs(a-b) ) >= 10^(-user_precision) ):

reduce_evalf := evalf:
reduce_conj :=  conjugate:

norpoly := (P,x) -> if user_simplify then expand(user_simplifycmd(normal(P))) else expand(normal(P)) end if;
norpoly2 := (P,x,y) -> if user_simplify then expand(user_simplifycmd(normal(P))) else expand(normal(P)) end if;
norpoly3 := (P,x,y,z) -> if user_simplify then expand(user_simplifycmd(normal(P))) else expand(normal(P)) end if;

reduce_coeff := proc( f, x )
    local g, g1, g2, j;
    g := norpoly(f,x);
    g1 := numer(g);
    g2 := denom(g);
    if g1 = 0 then [0] else [ coeff( g1, x, j )/g2 $ j = 0..degree( g1, x ) ] fi;
end:
openfile := proc()
    local kk, k, fh, fname;
    global currentopenfile, openfilelist;
    currentopenfile := {};

    for kk from 1 to nargs do
        fname := eval(args[kk]);
        if fname = terminal then
            currentopenfile := currentopenfile union { -infinity }
        else
            for k from 1 to nops(openfilelist) do
                if op(1,openfilelist[k]) = fname then break fi
            od;
            if k <= nops(openfilelist) then
                currentopenfile := currentopenfile union { op(2,openfilelist[k]) }
            else
                fh := fopen( fname, WRITE, TEXT );
                currentopenfile := currentopenfile union { fh };
                openfilelist := openfilelist union { [ fname, fh ] }
            fi
        fi
    od;
    if nops(currentopenfile)=0 then
        currentopenfile := {-infinity}
    fi;
end:
closefile := proc( filename )
    local k;
    global currentopenfile, openfilelist;

    if filename <> terminal then
        for k from 1 to nops(openfilelist) do
            if op(1,openfilelist[k]) = filename then
                break
            fi
        od;

        if k <= nops(openfilelist) then
            fclose( op(2,openfilelist[k]) );
            if member( op(2,openfilelist[k]), currentopenfile ) then
                currentopenfile := currentopenfile minus {op(2,openfilelist[k])};
                if nops(currentopenfile) = 0 then
                    currentopenfile := {-infinity}
                fi;
            fi;
            openfilelist := openfilelist minus { openfilelist[k] }
        fi

    else
        # filename=terminal
        if member( -infinity, currentopenfile ) and nops(currentopenfile)>1 then
            currentopenfile := currentopenfile minus {-infinity};
        fi;
    fi;
end:

closeallfiles := proc( filename )
    while nops( openfilelist ) <> 0 do
        closefile( op(1, openfilelist[1]) )
    od
end:

write_number := proc( n )
    if rounded then
        writef( "%g\n", evalf(n) )
    else
        writef( "%a\n", n) fi;
end:
writef := proc( formatstring )
    local j;
    for j from 1 to nops(currentopenfile) do
        if currentopenfile[j] = -infinity then
            printf( formatstring, args[2..nargs] )
        else
            fprintf( currentopenfile[j], formatstring, args[2..nargs] )
        fi
    od;
end:
optimizepolynomial1 := proc( f, x )
    local g, L, j, k, z;
    global user_precision, rounded;
    g := norpoly(f,x);
    if not rounded then
        g := convert( g, rational )
    else
        g := evalf( g )
    fi;
    L := eval( [ 'coeff( g, x, j )' $ j = 0..max(0,degree(g,x)) ] );
    if not(rounded) and user_simplify then
        L := map(user_simplifycmd,L)
    fi;
    L := map( z ->
        if type(evalf(z),numeric) then
            if abs(evalf(z)) <= 10^(-user_precision) then
                0
            else
                z
            end if
        else
            z
        end if, L );
    eval( add( L[k]*x^(k-1), k=1..nops(L) ) )
end:

optimizepolynomial2 := proc( f, x, y )
    local g, j, L, z;
    global rounded;
    g := norpoly2(f,x,y);
    if not rounded then
        g := convert( g, rational )
    else
        g := evalf( g )
    fi;
    L := eval( [ 'coeff( g, x, j )' $ j = 0..max(0,degree(g,x)) ] );
    L := map( z -> optimizepolynomial1( z, y ), L );
    norpoly( eval( add( L[k]*x^(k-1), k=1..nops(L) ) ), x );
end:

optimizevf :=  ( f, x, y ) ->
    [ optimizepolynomial2( f[1],x,y ), optimizepolynomial2( f[2], x, y ) ]:

change_poly := proc( f, x, y )
    local g, h, k, a;
    g := norpoly2( f, x, y );
    h := 0;
    while g <> 0 do
        k := nlterm( g, x, y );
        g := g - k;
        a := eval( eval( k, x=1 ), y=1 );
        if abs( evalf(a) ) > 10^(-user_precision) then h := h + k fi
    od;
    h
end:

first_term := proc( _f, x )
    local f;
    f := optimizepolynomial1( _f, x );
    if f = 0 then 0 else coeff( f, x, ldegree(f,x) )*x^(ldegree(f,x)) fi;
end:

lleadterm := proc( _f, x )
    local f;
    f := optimizepolynomial1( _f, x);
    if f = 0 then 0 else coeff( f, x, degree(f,x) )*x^(degree(f,x)) fi;
end:

nlterm := proc( f, x, y )
    local g, h;
    g := norpoly( lleadterm( f, x ), y );
    if g <> 0 then
        h := lleadterm( g, y );
        if h <> 0 then h else g fi
    else
        g := norpoly( lleadterm( f, y ), x );
        if g <> 0 then g else f fi
    fi
end:

ddeg := proc( _f, x, y )
    local f;
    global rounded;
    f := optimizepolynomial2( _f, x, y );
    if f = 0 then 0 else degree( f, {x,y} ) fi
end:

low_ddeg := proc( _f, x, y )
    local f;
    f := optimizepolynomial2( _f, x, y );
    if f = 0 then 0 else ldegree( f, {x,y} ) fi
end:

low_deg1 := proc( _f, x )
    local f;
    f := evalf( norpoly( _f ), x );
    if f = 0. then 0 else ldegree( f, x ) fi
end:

nterm := proc( _f, x, y, d )
    local f, j, g;
    f := optimizepolynomial2( _f, x, y );
    g := 0;
    for j from 0 to d do
        g := g + coeff( coeff( f, x, j ), y, d-j )*x^j*y^(d-j);
    od;
    g
end:

quasihom_degree1 := proc( _f, x, y, p, q )
    local _x, _y, f;
    f := optimizepolynomial2( _f, x, y );
    f := subs( x=_x^p, y=_y^q, f );
    degree( f, {_x, _y} )
end:

quasihom_degree :=( vf, x, y, p, q ) ->
    max( quasihom_degree1( vf[1],x,y,p,q ) - p, quasihom_degree1( vf[2],x,y,p,q ) - q ):
sort_list := s -> sort( s, (sle_a,sle_b) ->
    evalb( (sle_a[1] < sle_b[1]) or (sle_a[1] = sle_b[1] and sle_a[2] < sle_b[2]) ) ):

save( rounded, Hardware_precision, user_precision, reduce_coeff, write_number,
      reduce_evalf, reduce_llt, reduce_gt, reduce_gteq, reduce_eeq, reduce_nneq,
      optimizepolynomial1, optimizepolynomial2, first_term, lleadterm, nlterm,
      ddeg, low_ddeg, nterm, low_deg1, optimizevf, quasihom_degree1,
      quasihom_degree, change_poly, sort_list, reduce_imp,
      reduce_conj, reduce_re, reduce_im, openfile, closefile, writef,
      currentopenfile, openfilelist, closeallfiles, norpoly, norpoly2, norpoly3,
      "tools.m" );
